//$file${SMs::./Scr::bt_SPC51_SM.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: bt_SPC5x_SM.qm
// File:  ${SMs::./Scr::bt_SPC51_SM.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${SMs::./Scr::bt_SPC51_SM.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "em_common.h"
#include "app_assert.h"
#include "sl_sleeptimer.h"

#include "sl_bluetooth.h"
#include "gatt_db.h"


#include "app_button_press.h"
#include "sl_simple_button.h"
#include "sl_simple_button_instances.h"

#include "sl_simple_led.h"
#include "sl_simple_led_instances.h"

#include "app.h"
#include "app.h"
#include "qpc.h"

#include "bt_SPC51_SM.h"


//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${SMs::bt_SPC51_inst} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${SMs::bt_SPC51_inst} ......................................................
bt_SPC51 bt_SPC51_inst;
//$enddef${SMs::bt_SPC51_inst} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//static ToastOven l_oven; // the only instance of the ToastOven class

// global-scope definitions -----------------------------------------
QMsm * const QMsm_bt_SPC51_p = &bt_SPC51_inst.super; // the opaque pointer

//$define${SMs::bt_SPC51} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${SMs::bt_SPC51} ...........................................................

//${SMs::bt_SPC51::ctor} .....................................................
void bt_SPC51_ctor(bt_SPC51 * const me) {
    //remoteSM *me = &remote_inst;
    QMsm_ctor(&me->super, Q_STATE_CAST(&bt_SPC51_initial));
}

//${SMs::bt_SPC51::SM} .......................................................
QState bt_SPC51_initial(bt_SPC51 * const me, void const * const par) {
    //${SMs::bt_SPC51::SM::initial}
    (void)par; // unused parameter
    me->advertising_set_handle = 0xff;

    static QMTranActTable const tatbl_ = { // tran-action table
        &bt_SPC51_INITIALIZING_s, // target state
        {
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_INIT(&tatbl_);
}

//${SMs::bt_SPC51::SM::INITIALIZING} .........................................
QMState const bt_SPC51_INITIALIZING_s = {
    QM_STATE_NULL, // superstate (top)
    Q_STATE_CAST(&bt_SPC51_INITIALIZING),
    Q_ACTION_NULL, // no entry action
    Q_ACTION_NULL, // no exit action
    Q_ACTION_NULL  // no initial tran.
};
//${SMs::bt_SPC51::SM::INITIALIZING}
QState bt_SPC51_INITIALIZING(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::INITIALIZING::sl_bt_evt_system_boot_id}
        case sl_bt_evt_system_boot_id: {
            //Stack verion display
            app_log_info("Stack version: %u.%u.%u\r\r\n",
                       event->data.evt_system_boot.major,
                       event->data.evt_system_boot.minor,
                       event->data.evt_system_boot.patch);


            /* Print Bluetooth address */
            app_log_info("Bluetooth %s address: %02X:%02X:%02X:%02X:%02X:%02X\r\n",
                             me->address_type ? "static random" : "public device",
                             me->address.addr[5],
                             me->address.addr[4],
                             me->address.addr[3],
                             me->address.addr[2],
                             me->address.addr[1],
                             me->address.addr[0]);
                // Pad and reverse unique ID to get System ID.
                me->system_id[0] = me->address.addr[5];
                me->system_id[1] = me->address.addr[4];
                me->system_id[2] = me->address.addr[3];
                me->system_id[3] = 0xFF;
                me->system_id[4] = 0xFE;
                me->system_id[5] = me->address.addr[2];
                me->system_id[6] = me->address.addr[1];
                me->system_id[7] = me->address.addr[0];

            me->sc = sl_bt_gatt_server_write_attribute_value(gattdb_system_id,
                                                         0,
                                                         sizeof(me->system_id),
                                                         me->system_id);
            app_assert_status(me->sc);

            me->sc = sl_bt_sm_configure(INITIAL_FLAG_CONFIG, sl_bt_sm_io_capability_displayonly);
            app_assert_status(me->sc);

            //Delete any preivious bonding on start up if any
            //    me->sc = sl_bt_sm_delete_bondings();
            //app_assert_status(me->sc);

            //app_log_info("All bonding deleted.\n");

            ///set defualt connection parameters
            me->sc = sl_bt_connection_set_default_parameters(CONN_INTERVAL_MIN,
                                                       CONN_INTERVAL_MAX,
                                                       CONN_RESPONDER_LATENCY,
                                                       CONN_TIMEOUT,
                                                       CONN_MIN_CE_LENGTH,
                                                       CONN_MAX_CE_LENGTH);

            app_assert_status(me->sc);


            me->sc = sl_bt_advertiser_create_set(&me->advertising_set_handle);
            app_assert_status(me->sc);

            // Generate data for advertising
            me->sc = sl_bt_legacy_advertiser_generate_data(me->advertising_set_handle,
                                                     sl_bt_advertiser_general_discoverable);
            app_assert_status(me->sc);

            me->sc = sl_bt_advertiser_set_timing(
                                            me->advertising_set_handle,
                                            800U, 900U, // min & max interval (ms * 1.6)
                                            0U, 0U);    // duration, max events
            app_assert_status(me->sc);


            //sc = sl_bt_advertiser_set_channel_map(advertising_set_handle, (uint8_t)0x01);  // Only channel 37
            // Start advertising and enable connections.




            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { // tran-action table
                &bt_SPC51_OPERRATIONAL_s, // target state
                {
                    Q_ACTION_CAST(&bt_SPC51_OPERRATIONAL_i), // initial tran.
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}

//${SMs::bt_SPC51::SM::OPERRATIONAL} .........................................
QMState const bt_SPC51_OPERRATIONAL_s = {
    QM_STATE_NULL, // superstate (top)
    Q_STATE_CAST(&bt_SPC51_OPERRATIONAL),
    Q_ACTION_NULL, // no entry action
    Q_ACTION_NULL, // no exit action
    Q_ACTION_CAST(&bt_SPC51_OPERRATIONAL_i)
};
//${SMs::bt_SPC51::SM::OPERRATIONAL::initial}
QState bt_SPC51_OPERRATIONAL_i(bt_SPC51 * const me) {
    //${SMs::bt_SPC51::SM::OPERRATIONAL::initial}
    //after that restrict new connections
    me->sc = sl_bt_sm_configure((INITIAL_FLAG_CONFIG || (1U << 4)), sl_bt_sm_io_capability_displayonly);
    app_assert_status(me->sc);
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { // tran-action table
        &bt_SPC51_ADVERTISING_s, // target state
        {
            Q_ACTION_CAST(&bt_SPC51_ADVERTISING_e), // entry
            Q_ACTION_NULL // zero terminator
        }
    };
    return QM_TRAN_INIT(&tatbl_);
}
//${SMs::bt_SPC51::SM::OPERRATIONAL}
QState bt_SPC51_OPERRATIONAL(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::OPERRATIONAL::sl_bt_evt_gatt_server_attribute_~}
        case sl_bt_evt_gatt_server_attribute_value_id: {
            send_notification();
            status_ = QM_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::OPERRATIONAL::sl_bt_evt_connection_parameters_~}
        case sl_bt_evt_connection_parameters_id: {
            switch (event->data.evt_connection_parameters.security_mode)
                {
                case sl_bt_connection_mode1_level1:
                  app_log_info("No Security\n");
                  break;
                case sl_bt_connection_mode1_level2:
                  app_log_info("Unauthenticated pairing with encryption (Just Works)\n");
                  break;
                case sl_bt_connection_mode1_level3:
                  app_log_info("Authenticated pairing with encryption (Legacy Pairing)\n");
                  break;
                case sl_bt_connection_mode1_level4:
                  app_log_info("Authenticated Secure Connections pairing with encryption (BT 4.2 LE Secure Pairing)\n");
                  break;
                default:
                  break;
                }
            status_ = QM_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::OPERRATIONAL::sl_bt_evt_connection_closed_id}
        case sl_bt_evt_connection_closed_id: {
            app_log_info("Connection Closed....\n");

            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    Q_UNUSED_PAR(me);
    return status_;
}

//${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING} ............................
QMState const bt_SPC51_ADVERTISING_s = {
    &bt_SPC51_OPERRATIONAL_s, // superstate
    Q_STATE_CAST(&bt_SPC51_ADVERTISING),
    Q_ACTION_CAST(&bt_SPC51_ADVERTISING_e),
    Q_ACTION_NULL, // no exit action
    Q_ACTION_NULL  // no initial tran.
};
//${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING}
QState bt_SPC51_ADVERTISING_e(bt_SPC51 * const me) {
    me->sc = sl_bt_legacy_advertiser_start(me->advertising_set_handle,
                                     sl_bt_legacy_advertiser_connectable);
    app_assert_status(me->sc);

    app_log_info("Advertising....\n");

    sl_simple_button_enable(&sl_button_btn0);

    app_button_press_enable();

    return QM_ENTRY(&bt_SPC51_ADVERTISING_s);
}
//${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING}
QState bt_SPC51_ADVERTISING(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING::sl_bt_evt_connection_opened_id}
        case sl_bt_evt_connection_opened_id: {
            app_log_info("Connection Opened....\n");




            me->sc = sl_sleeptimer_stop_timer(&newConnectionTimer);

            if(me->sc == SL_STATUS_OK){
                app_log_info("New device connection timer halted...\n");
                sl_led_turn_off(&sl_led_led0);
                blink_count = 0U;
            }


            //me->sc = sl_bt_sm_increase_security(event->data.evt_connection_opened.connection);
            //app_assert_status(me->sc);


            //${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING::sl_bt_evt_connec~::[Newdevice]}
            if (SL_BT_INVALID_BONDING_HANDLE == event->data.evt_connection_opened.bonding) {
                app_log_info("New Device.\n");

                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { // tran-action table
                    &bt_SPC51_MANAGING_CONNECTION_s, // target state
                    {
                        Q_ACTION_CAST(&bt_SPC51_MANAGING_CONNECTION_e), // entry
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            //${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING::sl_bt_evt_connec~::[else]}
            else {
                app_log_info("Already Bonded.\n");
                me->sc = sl_bt_sm_increase_security(event->data.evt_connection_opened.connection);
                app_assert_status(me->sc);
                //me->sc = sl_bt_legacy_advertiser_start(me->advertising_set_handle,
                //                                 sl_bt_legacy_advertiser_connectable);
                //app_assert_status(me->sc);

                //app_log_info("advertising....\n");
                static struct {
                    QMState const *target;
                    QActionHandler act[2];
                } const tatbl_ = { // tran-action table
                    &bt_SPC51_ADVERTISING_s, // target state
                    {
                        Q_ACTION_CAST(&bt_SPC51_ADVERTISING_e), // entry
                        Q_ACTION_NULL // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        //${SMs::bt_SPC51::SM::OPERRATIONAL::ADVERTISING::sl_bt_evt_gatt_server_characteri~}
        case sl_bt_evt_gatt_server_characteristic_status_id: {
            if (event->data.evt_gatt_server_characteristic_status.status_flags == sl_bt_gatt_server_client_config) {
              if (event->data.evt_gatt_server_characteristic_status.client_config_flags == sl_bt_gatt_server_notification) {
                  // Notifications have been enabled by the client

                   notify_flag_change();


              }
            }
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    Q_UNUSED_PAR(me);
    return status_;
}

//${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECTION} ....................
QMState const bt_SPC51_MANAGING_CONNECTION_s = {
    &bt_SPC51_OPERRATIONAL_s, // superstate
    Q_STATE_CAST(&bt_SPC51_MANAGING_CONNECTION),
    Q_ACTION_CAST(&bt_SPC51_MANAGING_CONNECTION_e),
    Q_ACTION_NULL, // no exit action
    Q_ACTION_NULL  // no initial tran.
};
//${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECTION}
QState bt_SPC51_MANAGING_CONNECTION_e(bt_SPC51 * const me) {
    app_log_info("Managing New connection....\n");

    app_button_press_disable();

    me->sc = sl_bt_sm_increase_security(event->data.evt_connection_opened.connection);
    app_assert_status(me->sc);


    return QM_ENTRY(&bt_SPC51_MANAGING_CONNECTION_s);
}
//${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECTION}
QState bt_SPC51_MANAGING_CONNECTION(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECT~::sl_bt_evt_sm_passkey_display_id}
        case sl_bt_evt_sm_passkey_display_id: {
            app_log_info("PK: %06lu\n", event->data.evt_sm_passkey_display.passkey);
            //sl_iostream_write(sl_iostream_vcom_handle, &(event->data.evt_sm_passkey_display.passkey), (size_t)6U);
            printf("PK: %06lu\n", event->data.evt_sm_passkey_display.passkey);
            status_ = QM_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECT~::sl_bt_evt_sm_bonding_failed_id}
        case sl_bt_evt_sm_bonding_failed_id: {
            //failed bonding close the connection.
            me->sc = sl_bt_connection_close(
                          event->data.evt_sm_bonding_failed.connection);
            app_assert_status(me->sc);

            app_log_info("Bonding Failed....\n");
            app_log_info("Closing connection....\n");
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { // tran-action table
                &bt_SPC51_ADVERTISING_s, // target state
                {
                    Q_ACTION_CAST(&bt_SPC51_ADVERTISING_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        //${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECT~::sl_bt_evt_sm_confirm_bonding_id}
        case sl_bt_evt_sm_confirm_bonding_id: {
            me->sc = sl_bt_sm_bonding_confirm(event->data.evt_sm_confirm_bonding.connection, 1U);
            app_assert_status(me->sc);

            app_log_info("Remote bonding reqeust confirmed.\n");
            status_ = QM_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::OPERRATIONAL::MANAGING_CONNECT~::sl_bt_evt_sm_bonded_id}
        case sl_bt_evt_sm_bonded_id: {
            app_log_info("Bonded....\n");


            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { // tran-action table
                &bt_SPC51_ADVERTISING_s, // target state
                {
                    Q_ACTION_CAST(&bt_SPC51_ADVERTISING_e), // entry
                    Q_ACTION_NULL // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//$enddef${SMs::bt_SPC51} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define(SMs::remoteSM_ctor)
