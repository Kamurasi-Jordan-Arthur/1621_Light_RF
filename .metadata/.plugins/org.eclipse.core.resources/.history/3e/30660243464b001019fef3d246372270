//$file${SMs::./Scr::bt_SPC51_SM.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: remote_SM.qm
// File:  ${SMs::./Scr::bt_SPC51_SM.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${SMs::./Scr::bt_SPC51_SM.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "em_common.h"
#include "app_assert.h"
#include "sl_bluetooth.h"
#include "sl_sleeptimer.h"
#include "sl_simple_button.h"

#include "app.h"
#include "app.h"
#include "qpc.h"

#include "bt_SPC51_SM.h"


//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${SMs::bt_SPC51_inst} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${SMs::bt_SPC51_inst} ......................................................
static bt_SPC51 bt_SPC51_inst;
//$enddef${SMs::bt_SPC51_inst} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//static ToastOven l_oven; // the only instance of the ToastOven class

// global-scope definitions -----------------------------------------
QHsm * const Hsm_bt_SPC51_p = &bt_SPC51_inst.super; // the opaque pointer

//$define${SMs::bt_SPC51} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${SMs::bt_SPC51} ...........................................................

//${SMs::bt_SPC51::ctor} .....................................................
void bt_SPC51_ctor(bt_SPC51 * const me) {
    //remoteSM *me = &remote_inst;
    QHsm_ctor(&me->super, Q_STATE_CAST(&bt_SPC51_initial));
}

//${SMs::bt_SPC51::SM} .......................................................
QState bt_SPC51_initial(bt_SPC51 * const me, void const * const par) {
    //${SMs::bt_SPC51::SM::initial}
    (void)par; // unused parameter
    me->advertising_set_handle = 0xff;

    return Q_TRAN(&bt_SPC51_INITIALIZING);
}

//${SMs::bt_SPC51::SM::INITIALIZING} .........................................
QState bt_SPC51_INITIALIZING(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::INITIALIZING::sl_bt_evt_system_boot_id}
        case sl_bt_evt_system_boot_id_SIG: {
            //Stack verion display
            app_log_info("Stack version: %u.%u.%u\r\r\n",
                       event->data.evt_system_boot.major,
                       event->data.evt_system_boot.minor,
                       event->data.evt_system_boot.patch);


            /* Print Bluetooth address */
            app_log_info("Bluetooth %s address: %02X:%02X:%02X:%02X:%02X:%02X\r\n",
                             me->address_type ? "static random" : "public device",
                             me->address.addr[5],
                             me->address.addr[4],
                             me->address.addr[3],
                             me->address.addr[2],
                             me->address.addr[1],
                             me->address.addr[0]);
                // Pad and reverse unique ID to get System ID.
                me->system_id[0] = me->address.addr[5];
                me->system_id[1] = me->address.addr[4];
                me->system_id[2] = me->address.addr[3];
                me->system_id[3] = 0xFF;
                me->system_id[4] = 0xFE;
                me->system_id[5] = me->address.addr[2];
                me->system_id[6] = me->address.addr[1];
                me->system_id[7] = me->address.addr[0];

            me->sc = sl_bt_gatt_server_write_attribute_value(gattdb_system_id,
                                                         0,
                                                         sizeof(me->system_id),
                                                         me->system_id);
            app_assert_status(me->sc);

            me->sc = sl_bt_sm_configure(INITIAL_FLAG_CONFIG, sl_bt_sm_io_capability_displayonly);
            app_assert_status(me->sc);

            //Delete any preivious bonding on start up if any
            me->sc = sl_bt_sm_delete_bondings();
            app_assert_status(me->sc);

            app_log_info("All bonding deleted\r\n");

            ///set defualt connection parameters
            sc = sl_bt_connection_set_default_parameters(CONN_INTERVAL_MIN,
                                                       CONN_INTERVAL_MAX,
                                                       CONN_RESPONDER_LATENCY,
                                                       CONN_TIMEOUT,
                                                       CONN_MIN_CE_LENGTH,
                                                       CONN_MAX_CE_LENGTH);

            app_assert_status(me->sc);


            me->sc = sl_bt_advertiser_create_set(&me->advertising_set_handle);
            app_assert_status(me->sc);

            // Generate data for advertising
            me->sc = sl_bt_legacy_advertiser_generate_data(me->advertising_set_handle,
                                                     sl_bt_advertiser_general_discoverable);
            app_assert_status(me->sc);

            sc = sl_bt_advertiser_set_timing(
                                            advertising_set_handle,
                                            2400U, 3200U, // min & max interval (ms * 1.6)
                                            0U, 0U);    // duration, max events
                                            app_assert_status(sc);

            sl_simple_button_enable(sl_led_led0);

            //sc = sl_bt_advertiser_set_channel_map(advertising_set_handle, (uint8_t)0x01);  // Only channel 37
            // Start advertising and enable connections.




            status_ = Q_TRAN(&bt_SPC51_ADVERTISING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${SMs::bt_SPC51::SM::ADVERTISING} ..........................................
QState bt_SPC51_ADVERTISING(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::ADVERTISING}
        case Q_ENTRY_SIG: {
            me->sc = sl_bt_legacy_advertiser_start(me->advertising_set_handle,
                                             sl_bt_legacy_advertiser_connectable);
            app_assert_status(me->sc);

            app_log_info("Advertising....\n");

            blink_count = 0U;

            sl_simple_button_enable($sl_button_btn0);



            status_ = Q_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::ADVERTISING}
        case Q_EXIT_SIG: {

            sl_simple_button_disable($sl_button_btn0);

            status_ = Q_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::ADVERTISING::sl_bt_evt_connection_opened_id}
        case sl_bt_evt_connection_opened_id_SIG: {
            app_log_info("Connection Opened....\n");


            sc = sl_sleeptimer_stop_timer(newConnectionTimer);
            if(sc == SL_STATUS_OK){
                app_log_info("New device timer halted...\n");
            }


            status_ = Q_TRAN(&bt_SPC51_MANAGING_CONNECTION);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${SMs::bt_SPC51::SM::MANAGING_CONNECTION} ..................................
QState bt_SPC51_MANAGING_CONNECTION(bt_SPC51 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${SMs::bt_SPC51::SM::MANAGING_CONNECT~::sl_bt_evt_connection_parameters_~}
        case sl_bt_evt_connection_parameters_id_SIG: {
            switch (evt->data.evt_connection_parameters.security_mode)
                {
                case sl_bt_connection_mode1_level1:
                  app_log_info("No Security\n");
                  break;
                case sl_bt_connection_mode1_level2:
                  app_log_info("Unauthenticated pairing with encryption (Just Works)\n");
                  break;
                case sl_bt_connection_mode1_level3:
                  app_log_info("Authenticated pairing with encryption (Legacy Pairing)\n");
                  break;
                case sl_bt_connection_mode1_level4:
                  app_log_info("Authenticated Secure Connections pairing with encryption (BT 4.2 LE Secure Pairing)\n");
                  break;
                default:
                  break;
                }
            status_ = Q_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::MANAGING_CONNECT~::sl_bt_evt_sm_passkey_display_id}
        case sl_bt_evt_sm_passkey_display_id_SIG: {
            app_log("%06d\n", event->data.evt_sm_passkey_display.passkey);

            status_ = Q_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::MANAGING_CONNECT~::sl_bt_evt_sm_bonded_id}
        case sl_bt_evt_sm_bonded_id_SIG: {
            app_log_info("Bonded....\n");

            status_ = Q_TRAN(&bt_SPC51_ADVERTISING);
            break;
        }
        //${SMs::bt_SPC51::SM::MANAGING_CONNECT~::sl_bt_evt_sm_bonding_failed_id}
        case sl_bt_evt_sm_bonding_failed_id_SIG: {
            //failed bonding close the connection.
            me->sc = sl_bt_connection_close(
                          event->data.evt_sm_bonding_failed.connection);

            app_log_info("Bonding Failed....\n");
            status_ = Q_HANDLED();
            break;
        }
        //${SMs::bt_SPC51::SM::MANAGING_CONNECT~::sl_bt_evt_connection_closed_id}
        case sl_bt_evt_connection_closed_id_SIG: {
            app_log_info("Connection Closed....\n");
            status_ = Q_TRAN(&bt_SPC51_ADVERTISING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${SMs::bt_SPC51} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define(SMs::remoteSM_ctor)
